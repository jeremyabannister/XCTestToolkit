//
//  conformance_proofs.swift
//  
//
//  Created by Jeremy Bannister on 6/13/24.
//

///
extension AdditiveArithmetic {
    
    ///
    public func proofOfConformanceTo_AdditiveArithmetic() { }
    public static func proofOfConformanceTo_AdditiveArithmetic() { }
}

///
public func proofOfConformanceTo_AnyObject<T: AnyObject>(for t: T) { }
public func proofOfConformanceTo_AnyObject<T: AnyObject>(for t: T.Type) { }

///
extension CaseIterable {
    
    ///
    public func proofOfConformanceTo_CaseIterable() { }
    public static func proofOfConformanceTo_CaseIterable() { }
}

///
extension Decodable where Self: Encodable {
    
    ///
    public func proofOfConformanceTo_Codable() { }
    public static func proofOfConformanceTo_Codable() { }
}

///
extension CodingKey {
    
    ///
    public func proofOfConformanceTo_CodingKey() { }
    public static func proofOfConformanceTo_CodingKey() { }
}

///
extension Comparable {
    
    ///
    public func proofOfConformanceTo_Comparable() { }
    public static func proofOfConformanceTo_Comparable() { }
}

///
extension CustomStringConvertible {
    
    ///
    public func proofOfConformanceTo_CustomStringConvertible() { }
    public static func proofOfConformanceTo_CustomStringConvertible() { }
}

///
extension Decodable {
    
    ///
    public func proofOfConformanceTo_Decodable() { }
    public static func proofOfConformanceTo_Decodable() { }
}

///
extension Encodable {
    
    ///
    public func proofOfConformanceTo_Encodable() { }
    public static func proofOfConformanceTo_Encodable() { }
}

///
extension Equatable {
    
    ///
    public func proofOfConformanceTo_Equatable() { }
    public static func proofOfConformanceTo_Equatable() { }
}

///
extension Error {
    
    ///
    public func proofOfConformanceTo_Error() { }
    public static func proofOfConformanceTo_Error() { }
}

///
extension ExpressibleByFloatLiteral {
    
    ///
    public func proofOfConformanceTo_ExpressibleByFloatLiteral() { }
    public static func proofOfConformanceTo_ExpressibleByFloatLiteral() { }
}

///
extension ExpressibleByIntegerLiteral {
    
    ///
    public func proofOfConformanceTo_ExpressibleByIntegerLiteral() { }
    public static func proofOfConformanceTo_ExpressibleByIntegerLiteral() { }
}

///
extension Hashable {
    
    ///
    public func proofOfConformanceTo_Hashable() { }
    public static func proofOfConformanceTo_Hashable() { }
}

///
@available(iOS 13, macOS 10.15, watchOS 6, tvOS 13, *)
extension Identifiable {
    
    ///
    public func proofOfConformanceTo_Identifiable() { }
    public static func proofOfConformanceTo_Identifiable() { }
}

///
extension LocalizedError {
    
    ///
    public func proofOfConformanceTo_LocalizedError() { }
    public static func proofOfConformanceTo_LocalizedError() { }
}

///
extension Numeric {
    
    ///
    public func proofOfConformanceTo_Numeric() { }
    public static func proofOfConformanceTo_Numeric() { }
}

///
extension RawRepresentable {
    
    ///
    public func proofOfConformanceTo_RawRepresentable() { }
    public static func proofOfConformanceTo_RawRepresentable() { }
}

///
extension SignedNumeric {
    
    ///
    public func proofOfConformanceTo_SignedNumeric() { }
    public static func proofOfConformanceTo_SignedNumeric() { }
}
